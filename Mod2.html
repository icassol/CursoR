<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Datos y algunos algoritmos en R</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Curso R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="Index.html">Home</a>
</li>
<li>
  <a href="Mod1.html">Modulo 1</a>
</li>
<li>
  <a href="Mod2.html">Modulo 2</a>
</li>
<li>
  <a href="Mod3.html">Modulo 3</a>
</li>
<li>
  <a href="Mod4.html">Modulo 4</a>
</li>
<li>
  <a href="Mod5.html">Modulo 5</a>
</li>
<li>
  <a href="Mod6.html">Modulo 6</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Datos y algunos algoritmos en R</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#objetos"><span class="toc-section-number">1</span> Objetos</a></li>
<li><a href="#paquetes"><span class="toc-section-number">2</span> Paquetes</a></li>
<li><a href="#tipos-basicos-de-datos"><span class="toc-section-number">3</span> Tipos básicos de datos</a><ul>
<li><a href="#factores"><span class="toc-section-number">3.1</span> Factores</a></li>
<li><a href="#variables-logicas"><span class="toc-section-number">3.2</span> Variables lógicas</a></li>
</ul></li>
<li><a href="#arreglos"><span class="toc-section-number">4</span> Arreglos</a><ul>
<li><a href="#longitud"><span class="toc-section-number">4.1</span> Longitud</a></li>
<li><a href="#acceso-a-los-componentes"><span class="toc-section-number">4.2</span> Acceso a los componentes</a></li>
<li><a href="#seleccion-condicionada-de-valores"><span class="toc-section-number">4.3</span> Selección condicionada de valores</a></li>
<li><a href="#funcion-unique"><span class="toc-section-number">4.4</span> Función <code>unique()</code></a></li>
<li><a href="#funcion-table"><span class="toc-section-number">4.5</span> Función <code>table()</code></a></li>
<li><a href="#operaciones-con-variables-numericas"><span class="toc-section-number">4.6</span> Operaciones con variables numéricas</a></li>
<li><a href="#operaciones-con-arreglos-de-clase-character."><span class="toc-section-number">4.7</span> Operaciones con arreglos de clase <code>character</code>.</a></li>
<li><a href="#el-paquete-stringr"><span class="toc-section-number">4.8</span> El paquete <code>stringr</code></a></li>
</ul></li>
<li><a href="#matrices"><span class="toc-section-number">5</span> Matrices</a><ul>
<li><a href="#operaciones"><span class="toc-section-number">5.1</span> Operaciones</a></li>
</ul></li>
<li><a href="#data.frames"><span class="toc-section-number">6</span> Data.frames</a><ul>
<li><a href="#creacion"><span class="toc-section-number">6.1</span> Creación</a></li>
<li><a href="#convertir-una-matriz-en-data.frame"><span class="toc-section-number">6.2</span> Convertir una matriz en data.frame</a></li>
<li><a href="#acceso-a-variables"><span class="toc-section-number">6.3</span> Acceso a variables</a></li>
<li><a href="#eliminar-repetidos.-merge"><span class="toc-section-number">6.4</span> Eliminar repetidos. <code>merge()</code></a></li>
<li><a href="#ordenamiento"><span class="toc-section-number">6.5</span> Ordenamiento</a></li>
<li><a href="#funcion-table-1"><span class="toc-section-number">6.6</span> función <code>table()</code></a></li>
</ul></li>
<li><a href="#listas"><span class="toc-section-number">7</span> Listas</a></li>
<li><a href="#coercion"><span class="toc-section-number">8</span> Coerción</a></li>
<li><a href="#algunas-operaciones-basicas"><span class="toc-section-number">9</span> Algunas operaciones básicas</a><ul>
<li><a href="#funciones-matematicas"><span class="toc-section-number">9.1</span> Funciones matemáticas</a></li>
<li><a href="#algunas-funciones"><span class="toc-section-number">9.2</span> Algunas funciones</a></li>
</ul></li>
<li><a href="#algunos-conceptos-algoritmicos-en-r"><span class="toc-section-number">10</span> Algunos conceptos algorítmicos en R</a><ul>
<li><a href="#flujos-de-control"><span class="toc-section-number">10.1</span> Flujos de control</a></li>
<li><a href="#funciones"><span class="toc-section-number">10.2</span> Funciones</a></li>
</ul></li>
</ul>
</div>

<!-- see http://rmarkdown.rstudio.com/ for details in formatting -->
<hr />
<blockquote>
<p><strong><em>Help operator</em></strong>: R provee el operador <code>?</code> para conocer las opciones y parámetros de las instrucciones. Ej: <code>help(&quot;paste&quot;)</code> o <code>?paste</code>.</p>
</blockquote>
<hr />
<div id="objetos" class="section level1">
<h1><span class="header-section-number">1</span> Objetos</h1>
<p>En términos genéricos, todos los elementos que maneja R son objetos: un valor numérico es un objeto, un arreglo es un objeto, una función es un objeto, una base de datos es un objeto, un gráfico es un objeto, …</p>
<p>Para realizar un uso eficiente de R es preciso entender y aprender a manipular bien las distintas clases de objetos que maneja el programa. En esta sección nos vamos a ocupar particulamente de aquellos objetos que R utiliza para representar datos: valores, vectores, matrices, dataframes, series temporales y listas.</p>
<p>R utiliza, de hecho, programación orientada a objetos. Ello significa que una misma función hace cosas distintas según la clase del objeto que recibe como argumento, pudiendo incluso no hacer nada (o producir un error) si se le pasan argumentos de una clase inadecuada.</p>
<p>A modo de ejemplo, veamos cómo la función <code>plot()</code> puede mostrar distintos gráficos según la clase del objeto a representar. Para ello supongamos que el siguiente arreglo representa el número de personas atendidas mensualmente en el servicio de urgencias de un centro de salud durante el año 2000 (datos de enero a diciembre):</p>
<pre class="r"><code>atendidos &lt;- c(728,632,596,689,745,865,694,583,657,643,794,887)
atendidos</code></pre>
<pre><code>##  [1] 728 632 596 689 745 865 694 583 657 643 794 887</code></pre>
<p>La asignación de valores a un variable se realiza a través del operador <code>&lt;-</code>. En este caso, la variable <code>atendidos</code> recibe 12 números.</p>
<pre class="r"><code>class(atendidos)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>La función <code>class()</code> nos devuelve la clase del objeto atendidos, que como vemos es <code>numeric</code>. Podemos obtener una representación gráfica de este arreglo simplemente mediante:</p>
<pre class="r"><code>plot(atendidos)</code></pre>
<p><img src="Mod2_files/figure-html/unnamed-chunk-3-1.png" width="432" /></p>
<p>Ahora convertimos estos datos en serie temporal mediante la función ts(), indicando que esta serie comienza en enero del año 2009 y que tiene una frecuencia de 12 observaciones por año (esto es, una por mes):</p>
<pre class="r"><code>atendidos2 &lt;- ts(atendidos,frequency=12,start=c(2009,1))
atendidos2</code></pre>
<pre><code>##      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
## 2009 728 632 596 689 745 865 694 583 657 643 794 887</code></pre>
<pre class="r"><code>class(atendidos2)</code></pre>
<pre><code>## [1] &quot;ts&quot;</code></pre>
<p>Como podemos ver, la clase del objeto <code>atendidos2</code> es <code>ts</code> (time series). Podemos comprobar que si aplicamos la misma función <code>plot()</code> a <code>atendidos2</code>, el gráfico obtenido es distinto que cuando se aplica a <code>atendidos</code>, aún cuando los datos sean exactamente los mismos:</p>
<pre class="r"><code>plot(atendidos2)</code></pre>
<p><img src="Mod2_files/figure-html/unnamed-chunk-6-1.png" width="432" /></p>
<hr />
</div>
<div id="paquetes" class="section level1">
<h1><span class="header-section-number">2</span> Paquetes</h1>
<p>Una de las grandes potencialidades que tiene R es la utilización de paquetes (o librerías). R tiene una serie de comandos que se cargan por default. Sin embargo, hay una gran cantidad de funcionalidades que se deben cargar a través de paquetes.</p>
<p>Un paquete (package) es una colección de funciones, datos y código R que se almacenan en una carpeta conforme a una estructura bien definida, fácilmente accesible para R. En la web de R se puede consultar la lista de paquetes disponibles.</p>
<p>Puede haber paquetes: * <strong>Instalados en R pero que no están en memoria</strong>. Son paquetes que se han descargado junto con la instalación de R pero que, para su uso, se requiere cargarlos en memoria. Ejemplo:</p>
<pre class="r"><code>library(&quot;plyr&quot;)</code></pre>
<ul>
<li><strong>No instalados en R</strong>. Son paquetes que 1º debes instalar y luego cargarlos en memoria. Por ejemplo:</li>
</ul>
<pre class="r"><code>if (!is.element(&quot;readr&quot;, installed.packages()[,1])){
  install.packages(&quot;readr&quot;, repos = &quot;http://mirror.fcaglp.unlp.edu.ar/CRAN/&quot;)
}
library(&quot;readr&quot;)</code></pre>
<ul>
<li><strong>En memoria</strong>. Estos paquetes se cargan automáticamente en memoria cuando se agre Rstudio, o cuando se utiliza R.</li>
</ul>
<p>Veamos un ejemplo:</p>
<p>R posee, en memoria, una tabla-ejemplo llamada <code>airquality</code>. Se puede ver por consola escribiendo su nombre+Enter. Si quisieramos cambiar el signo de los valores de la columna “Ozone”, podríamos cargar el paquete “plyr” que contiene la función “mutate()”. Este paquete ya está instalado pero se requiere cargarlo en memoria. Para eso vamos a cargar en memoria el paquete:</p>
<pre class="r"><code>library(&quot;plyr&quot;)</code></pre>
<p>Ahora que el paquete está en memoria, podemos ejecutar la instrucción:</p>
<pre class="r"><code>head(mutate(airquality, Ozone = -Ozone))</code></pre>
<pre><code>##   Ozone Solar.R Wind Temp Month Day
## 1   -41     190  7.4   67     5   1
## 2   -36     118  8.0   72     5   2
## 3   -12     149 12.6   74     5   3
## 4   -18     313 11.5   62     5   4
## 5    NA      NA 14.3   56     5   5
## 6   -28      NA 14.9   66     5   6</code></pre>
<p>Y podremos ver por consola cómo combió el signo.</p>
<p>En el area <strong><em>File/Plots/Packages/Help/Viewer:</em></strong>, si haces click en “Packages” podrás ver un listado de paquetes, y qué paquetes tienes instalados. Puedes instalar paquetes haciendo click en “Install”.</p>
<p>En <a href="https://cran.r-project.org/web/packages/index.html">este link</a> puedes ver un listado completo de paquetes disponibles.</p>
<hr />
</div>
<div id="tipos-basicos-de-datos" class="section level1">
<h1><span class="header-section-number">3</span> Tipos básicos de datos</h1>
<p>R distingue los siguientes tipos de variables:</p>
<ul>
<li><strong>numeric</strong>: variables numéricas continuas.</li>
</ul>
<pre class="r"><code>a &lt;- 2.15</code></pre>
<ul>
<li><strong>integer</strong>: variables numéricas discretas.</li>
</ul>
<pre class="r"><code>b &lt;- 3
c &lt;- as.integer(a) # para transformar un variable float en entera. </code></pre>
<ul>
<li><strong>character</strong>: variables alfanuméricas; sus valores son combinaciones de cifras y letras.</li>
<li><strong>factor</strong>: variables categóricas; R almacena internamente los valores de un factor como números enteros, pero los muestra como valores alfanuméricos.</li>
</ul>
<div id="factores" class="section level2">
<h2><span class="header-section-number">3.1</span> Factores</h2>
<p>Un factor es una variable categórica con un número finito de valores o niveles. En R los factores se utilizan habitualmente para realizar clasificaciones de los datos, estableciendo su pertenencia a los grupos o categorías determinados por los niveles del factor.</p>
<p>Los factores juegan un papel muy importante en la elaboración de modelos estadísticos. En particular, los modelos lineales pueden dar resultados muy diferentes según que una variable se declare como numérica o como factor.</p>
<p>Los niveles de un factor puede estar codificados como valores numéricos o como caracteres. Independientemente de que el factor sea numérico o carácter, sus valores son siempre almacenados internamente por R como números enteros, con lo que se consigue economizar memoria.</p>
<p>Consideremos el siguiente ejemplo. La variable:</p>
<pre class="r"><code>sexo &lt;- c(&quot;M&quot;, &quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;)
sexo</code></pre>
<pre><code>##  [1] &quot;M&quot; &quot;H&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;H&quot; &quot;M&quot; &quot;M&quot; &quot;H&quot; &quot;H&quot;</code></pre>
<p>puede ser considerada un factor, ya que establece para cada sujeto su pertenencia a una de las dos categorías “Hombre”&quot; o “Mujer”. Para que R reconozca al sexo como factor, una vez introducidos los datos utilizamos la función:</p>
<pre class="r"><code>sexo &lt;- factor(sexo)
sexo</code></pre>
<pre><code>##  [1] M H M M M H M M H H
## Levels: H M</code></pre>
<p>con lo que hemos convertido sexo en un factor con dos niveles M y H. En muchos casos, los niveles del factor son poco ilustrativos de su significado. La siguiente sintaxis especifica explícitamente los niveles del factor (levels) y asigna etiquetas (labels) a cada uno de ellos:</p>
<pre class="r"><code>sexo &lt;- factor(sexo,levels=c(&quot;H&quot;,&quot;M&quot;),labels=c(&quot;Hombre&quot;,&quot;Mujer&quot;))
sexo</code></pre>
<pre><code>##  [1] Mujer  Hombre Mujer  Mujer  Mujer  Hombre Mujer  Mujer  Hombre Hombre
## Levels: Hombre Mujer</code></pre>
<p>Estas etiquetas aparecerán en los resultados de los procedimientos estadísticos donde apareza el factor, aclarando su significado. Por ejemplo, si pedimos a R que nos construya la tabla de frecuencias de sexos, en lugar de H o M nos mostrará los términos “Hombre”&quot; o “Mujer”:</p>
<pre class="r"><code>table(sexo)</code></pre>
<pre><code>## sexo
## Hombre  Mujer 
##      4      6</code></pre>
<p>Hay alguna funciones en R que requieren que la variable de entrada sea necesariamente un factor (aún cuando la variable esté codificada numéricamente). Para ello basta recodificar la variable original como factor. Por ejemplo, supongamos que se ha registrado la producción de tres máquinas (identificadas como 27, 32 y 55) durante cinco días sucesivos, dando como resultado los siguientes datos:</p>
<pre class="r"><code>produccion=c(120,100,132,112,95,164,172,183,155,176,110,115,122,108,120)
maquina=c(27,27,27,27,27,32,32,32,32,32,55,55,55,55,55)
dia=c(1,2,3,4,5,1,2,3,4,5,1,2,3,4,5)
cbind(maquina,dia,produccion)</code></pre>
<pre><code>##       maquina dia produccion
##  [1,]      27   1        120
##  [2,]      27   2        100
##  [3,]      27   3        132
##  [4,]      27   4        112
##  [5,]      27   5         95
##  [6,]      32   1        164
##  [7,]      32   2        172
##  [8,]      32   3        183
##  [9,]      32   4        155
## [10,]      32   5        176
## [11,]      55   1        110
## [12,]      55   2        115
## [13,]      55   3        122
## [14,]      55   4        108
## [15,]      55   5        120</code></pre>
<p>Si se pretende evaluar la producción de estas tres máquinas a lo largo de estos días, es evidente que sus números de identificación (27, 32 y 55) son simples etiquetas sin que su valor intrínseco tenga ningún sentido en el problema. En este caso resulta razonable (y, como veremos, en el ajuste de modelos de análisis de la varianza es además necesario) convertir esta variable en factor. Para ello simplemente ejecutamos:</p>
<pre class="r"><code>maquina=factor(maquina)
maquina</code></pre>
<pre><code>##  [1] 27 27 27 27 27 32 32 32 32 32 55 55 55 55 55
## Levels: 27 32 55</code></pre>
<div id="coercion-de-factores" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Coerción de factores</h3>
<p>Un factor puede convertirse en variable numérica mediante la función as.numeric(). Ahora bien, dichas conversiones deben realizarse con cierta precaución. Así por ejemplo, si en el caso anterior aplicamos la función as.numeric() al factor maquina obtenemos:</p>
<pre class="r"><code>as.numeric(maquina)  </code></pre>
<pre><code>##  [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3</code></pre>
<p>¡No se han recuperado los valores originales 27, 32 y 55!. Lo que ocurre en este caso es que R muestra la codificación interna de los niveles del factor (habitualmente valores enteros ordenados desde 1 hasta el número total de niveles). Si quisiéramos recuperar los valores numéricos originales de la variable maquina debemos primero convertirla en carácter, y a continuación en numérica:</p>
<pre class="r"><code>as.numeric(as.character(maquina))</code></pre>
<pre><code>##  [1] 27 27 27 27 27 32 32 32 32 32 55 55 55 55 55</code></pre>
</div>
</div>
<div id="variables-logicas" class="section level2">
<h2><span class="header-section-number">3.2</span> Variables lógicas</h2>
<p>Las variables lógicas constituyen un tipo particular de factor en R, que se caracteriza por tomar sólo dos valores: <strong>TRUE</strong> o <strong>FALSE</strong> codificados, respectivamente, como 1 y 0. Es posible construir condiciones lógicas utilizando los operadores ‘y’ (<code>&amp;</code>), ‘o’ (<code>|</code>) y ‘no’ (<code>!</code>).</p>
<p>La comparación de valores se lleva a cabo mediante <code>==</code> (‘es igual a’) y <code>!=</code> (‘es distinto de’).</p>
<p>ATENCIÓN: No debe confundirse el operador de asignación = con el de comparación ==.</p>
<p>Veamos algunos ejemplos:</p>
<pre class="r"><code>a &lt;- 2
b &lt;- 4
a==b  # ¿es a igual a b?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>a!=b  # ¿es a distinto de b?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>(a&lt;3)&amp;(b&lt;5)  # ¿es a menor que 3 y b menor que 3?</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>(a&lt;1)|(b&lt;3)  # ¿es a menor que 1 o b menor que 3?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Funciones any() y all()</p>
<p>Las funciones any(x) y all(x) determinan, respectivamente, si alguno o todos los elementos de x son TRUE:</p>
<pre class="r"><code>any(c(a==2, a==3, a==4))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>any(c(a==3, a==4, a==5, a==6))</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>all(c(a==2, b==4, 2&lt;3))</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
</div>
<div id="arreglos" class="section level1">
<h1><span class="header-section-number">4</span> Arreglos</h1>
<p>Se pueden agrupar varios elementos de la misma clase para formar un arreglo mediante el comando de concatenación <code>c()</code>. Así, podemos guardar las edades de 10 personas de una muestra en la variable edad mediante:</p>
<pre class="r"><code>edad &lt;- c(22, 34, 29, 25, 30, 33, 31, 27, 25, 25)
edad</code></pre>
<pre><code>##  [1] 22 34 29 25 30 33 31 27 25 25</code></pre>
<pre class="r"><code>class(edad)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<div id="longitud" class="section level2">
<h2><span class="header-section-number">4.1</span> Longitud</h2>
<p>La función <code>length()</code> devuelve la longitud (número de elementos) del arreglo:</p>
<pre class="r"><code>x &lt;- c(1,4,5,2,4,5,4,3,2,2,3,2,2,4,4,5,5,6,6,7)
length(x)</code></pre>
<pre><code>## [1] 20</code></pre>
</div>
<div id="acceso-a-los-componentes" class="section level2">
<h2><span class="header-section-number">4.2</span> Acceso a los componentes</h2>
<p>Es posible acceder al valor que ocupa la posición <code>k</code> dentro de un arreglo <code>x</code> refiriéndonos a él como <code>x[k]</code>. Así, por ejemplo, podemos ver el contenido del tercer y quinto valores del arreglo <code>edad</code>:</p>
<pre class="r"><code>edad &lt;- c(22, 34, 29, 25, 30, 33, 31, 27, 25, 25)
edad[3]</code></pre>
<pre><code>## [1] 29</code></pre>
<pre class="r"><code>edad[5]</code></pre>
<pre><code>## [1] 30</code></pre>
<div id="operador" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Operador <code>:</code></h3>
<p>Si deseamos asignar a una variable una sucesión de valores consecutivos podemos utilizar el operador <code>:</code>. Así para asignar a la variable x los valores de 1 a 10 procederíamos del siguiente modo:</p>
<pre class="r"><code>x &lt;- 1:10
x</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p>Podemos construir secuencias de números más complejas mediante la función <code>seq()</code>:</p>
<p>Sucesión de valores de 1 a 20 de 2 en 2:</p>
<pre class="r"><code>x &lt;- seq(1,20,by=2)
x</code></pre>
<pre><code>##  [1]  1  3  5  7  9 11 13 15 17 19</code></pre>
<p>Sucesión de 8 valores equiespaciados entre 1 y 20:</p>
<pre class="r"><code>y &lt;- seq(1,20,length=8)
y</code></pre>
<pre><code>## [1]  1.000000  3.714286  6.428571  9.142857 11.857143 14.571429 17.285714 20.000000</code></pre>
<p>Podemos acceder también simultáneamente a varios valores dentro de un arreglo. Por ejemplo, si deseamos ver del segundo al quinto de los valores observados en la variable edad:</p>
<pre class="r"><code>edad[2:5]</code></pre>
<pre><code>## [1] 34 29 25 30</code></pre>
<p>Y si quisiéramos ver sólo los valores primero, tercero y séptimo:</p>
<pre class="r"><code>edad[c(1,3,7)]</code></pre>
<pre><code>## [1] 22 29 31</code></pre>
</div>
<div id="operador-in" class="section level3">
<h3><span class="header-section-number">4.2.2</span> Operador `%in%</h3>
<p>La función %in% permite determinar si uno o varios valores están contenidos en un arreglo:</p>
<pre class="r"><code>x &lt;- 1:10
a &lt;- 2
a %in% x</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>b &lt;- c(6,8,14,2,15)
b %in% x</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE  TRUE FALSE</code></pre>
</div>
</div>
<div id="seleccion-condicionada-de-valores" class="section level2">
<h2><span class="header-section-number">4.3</span> Selección condicionada de valores</h2>
<p>La función <code>which()</code> nos da las posiciones, dentro de un arreglo, de los valores que cumplen cierta condición. Por ejemplo, si definimos:</p>
<pre class="r"><code>edad &lt;- c(22, 34, 29, 25, 30, 33, 31, 27, 25, 25)</code></pre>
<p>La siguiente función nos devuelve las posiciones de los valores de este arreglo que son mayores que 25:</p>
<pre class="r"><code>which(edad&gt;25)</code></pre>
<pre><code>## [1] 2 3 5 6 7 8</code></pre>
<p>Esto es: los valores del arreglo <code>edad</code> mayores que 25 son los que ocupan las posiciones 2, 3, 5, 6, 7 y 8.</p>
<p>Podemos asignar estas posiciones a una nueva variable:</p>
<pre class="r"><code>mayores25 &lt;- which(edad&gt;25)</code></pre>
<p>y utilizarla para mostrar cuáles son concretamente esos valores mediante:</p>
<pre class="r"><code>edad[mayores25]</code></pre>
<pre><code>## [1] 34 29 30 33 31 27</code></pre>
<p>Esta expresión puede simplificarse, si no utilizamos <code>which()</code>:</p>
<pre class="r"><code>edad[edad&gt;25]</code></pre>
<pre><code>## [1] 34 29 30 33 31 27</code></pre>
<p>La operación <code>which()</code> es aplicable también a otras estructuras de datos en R. Es, en efecto, un operador potente para la ciencia de datos.</p>
<p>Se puede realizar también la selección de valores de un arreglo condicionando por los valores de otro arreglo. Por ejemplo, si las diez edades del ejemplo anterior corresponden a personas cuyo sexo viene dado por:</p>
<pre class="r"><code>sexo &lt;- c(&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;)</code></pre>
<p>podríamos seleccionar la edad de las mujeres simplemente mediante:</p>
<pre class="r"><code>edad[sexo==&quot;M&quot;]</code></pre>
<pre><code>## [1] 22 25 30 31 27</code></pre>
</div>
<div id="funcion-unique" class="section level2">
<h2><span class="header-section-number">4.4</span> Función <code>unique()</code></h2>
<p>Es frecuente que, dado un conjunto de datos, nos interese solamente conocer los valores, sin importar su repetición en el conjunto:</p>
<pre class="r"><code>unique(sexo)</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;H&quot;</code></pre>
</div>
<div id="funcion-table" class="section level2">
<h2><span class="header-section-number">4.5</span> Función <code>table()</code></h2>
<p>Si quisieramos conocer cuántas repeticiones tiene cada elemento se puede utilizar:</p>
<pre class="r"><code>table(edad)</code></pre>
<pre><code>## edad
## 22 25 27 29 30 31 33 34 
##  1  3  1  1  1  1  1  1</code></pre>
</div>
<div id="operaciones-con-variables-numericas" class="section level2">
<h2><span class="header-section-number">4.6</span> Operaciones con variables numéricas</h2>
<p>Si <code>x</code> e <code>y</code> son dos arreglos de la misma dimensión, las operaciones elementales se realizan término a término (característica que se conoce como aritmética vectorial):</p>
<pre class="r"><code>x &lt;- seq(2,20,by=2)  # Números pares entre 2 y 20
x</code></pre>
<pre><code>##  [1]  2  4  6  8 10 12 14 16 18 20</code></pre>
<pre class="r"><code>y &lt;- seq(1,20,by=2)  # Números impares entre 1 y 20
y</code></pre>
<pre><code>##  [1]  1  3  5  7  9 11 13 15 17 19</code></pre>
<pre class="r"><code>x+y</code></pre>
<pre><code>##  [1]  3  7 11 15 19 23 27 31 35 39</code></pre>
<pre class="r"><code>x-y</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 1 1</code></pre>
<pre class="r"><code>x*y</code></pre>
<pre><code>##  [1]   2  12  30  56  90 132 182 240 306 380</code></pre>
<pre class="r"><code>x/y</code></pre>
<pre><code>##  [1] 2.000000 1.333333 1.200000 1.142857 1.111111 1.090909 1.076923 1.066667 1.058824 1.052632</code></pre>
</div>
<div id="operaciones-con-arreglos-de-clase-character." class="section level2">
<h2><span class="header-section-number">4.7</span> Operaciones con arreglos de clase <code>character</code>.</h2>
<p>En R se pueden declarar arreglos alfanuméricos (o de clase carácter):</p>
<pre class="r"><code>letras &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
class(letras)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<ul>
<li><code>paste()</code>: esta función “pega” (o concatena) variables de clase <code>character</code>; la opción <code>sep</code> indica el símbolo que separa los valores que se han pegado; en caso de que no se quiera dejar ningún símbolo de separación, debe usarse <code>sep=&quot;&quot;</code>:</li>
</ul>
<pre class="r"><code>paste(&quot;A&quot;,&quot;B&quot;,sep=&quot;-&quot;)</code></pre>
<pre><code>## [1] &quot;A-B&quot;</code></pre>
<p>Podemos pegar arreglos (se pegarán término a término: primer valor con primer valor, segundo con segundo, etc.)</p>
<pre class="r"><code>codigos &lt;- paste(c(&quot;A&quot;, &quot;B&quot;), 2:3, sep = &quot;&quot;)
codigos</code></pre>
<pre><code>## [1] &quot;A2&quot; &quot;B3&quot;</code></pre>
<pre class="r"><code>codigos &lt;- paste(c(&quot;A&quot;, &quot;B&quot;), 2:3, sep = &quot;.&quot;)
codigos</code></pre>
<pre><code>## [1] &quot;A.2&quot; &quot;B.3&quot;</code></pre>
<p>Obsérvese, que con la opción <code>sep</code> se obtiene como resultado un arreglo de la misma longitud que los arreglos que se pegan.</p>
<p>Cuando se utiliza <code>paste()</code> sobre un único arreglo con la opción <code>collapse</code>, se “pegan” todos los términos del arreglo en un único valor:</p>
<pre class="r"><code>paste(c(&quot;una&quot;, &quot;frase&quot;, &quot;simple&quot;), collapse = &quot; &quot;)</code></pre>
<pre><code>## [1] &quot;una frase simple&quot;</code></pre>
<div id="seleccionasignacion-de-una-parte-de-una-cadena-de-caracteres." class="section level3">
<h3><span class="header-section-number">4.7.1</span> Selección/asignación de una parte de una cadena de caracteres.</h3>
<p>La función <code>substr(x,n1,n2)</code> selecciona los caracteres de <code>x</code> entre las posiciones <code>n1</code> y <code>n2</code>. También permite realizar asignaciones:</p>
<pre class="r"><code>substr(&quot;abcdef&quot;, 2, 4)</code></pre>
<pre><code>## [1] &quot;bcd&quot;</code></pre>
<pre class="r"><code>x &lt;- &quot;ABCDEF&quot;
x</code></pre>
<pre><code>## [1] &quot;ABCDEF&quot;</code></pre>
<pre class="r"><code>substr(x, 3, 5) &lt;- c(&quot;uv&quot;)
x</code></pre>
<pre><code>## [1] &quot;ABuvEF&quot;</code></pre>
<p>Tarea:</p>
<p>Utiliza la ayuda de R para averiguar la utilidad de las funciones <code>nchar</code>, <code>grep</code>, <code>match</code>, <code>tolower</code>, <code>toupper</code>.</p>
</div>
</div>
<div id="el-paquete-stringr" class="section level2">
<h2><span class="header-section-number">4.8</span> El paquete <code>stringr</code></h2>
<p>El paquete <a href="https://cran.r-project.org/web/packages/stringr/index.html"><code>stringr</code></a> ofrece funciones para el manejo de caracteres. Como este paquete no viene con R, hay que instalarlo y cargarlo en memoria:</p>
<pre class="r"><code>if (!is.element(&quot;stringr&quot;, installed.packages()[,1])){
  install.packages(&quot;stringr&quot;)
}
library(stringr)</code></pre>
<p>La siguiente tabla contiene algunas funciones de <code>stringr</code> para operar sobre caracteres:</p>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
<th align="left">Similar to</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>str_c()</code></td>
<td align="left">concatenación de string</td>
<td align="left"><code>paste()</code></td>
</tr>
<tr class="even">
<td align="left"><code>str_length()</code></td>
<td align="left">número de caracteres</td>
<td align="left"><code>nchar()</code></td>
</tr>
<tr class="odd">
<td align="left"><code>str_sub()</code></td>
<td align="left">extraer substrings</td>
<td align="left"><code>substring()</code></td>
</tr>
<tr class="even">
<td align="left"><code>str_dup()</code></td>
<td align="left">duplicar caracterires</td>
<td align="left"><em>none</em></td>
</tr>
<tr class="odd">
<td align="left"><code>str_trim()</code></td>
<td align="left">remover espacios blancos (inicio y fin)</td>
<td align="left"><em>none</em></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="matrices" class="section level1">
<h1><span class="header-section-number">5</span> Matrices</h1>
<p>En R las matrices solamente pueden ser numéricas y hay varias maneras de definirlas. Si es pequeña podemos utilizar la siguiente sintaxis:</p>
<pre class="r"><code>A &lt;- matrix(nrow=3,ncol=3, c(1,2,3,4,5,6,7,8,9), byrow=TRUE)</code></pre>
<p>Con el argumento <code>nrow</code> hemos indicado el número de filas de nuestra matriz, con <code>ncol</code> el número de columnas. A continuación hemos puesto los valores que forman la matriz (los valores del 1 al 9), y le hemos pedido a R que use esos valores para rellenar la matriz <code>A</code> por filas `(byrow=TRUE)´. La matriz A así construida es:</p>
<pre class="r"><code>A</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9</code></pre>
<p>Tarea:</p>
<p>Comprueba cómo queda la matriz si se utiliza <code>byrow=FALSE</code>.</p>
<p>Se pueden seleccionar partes de una matriz utilizando los índices de posición [fila, columna] entre corchetes. El siguiente ejemplo ilustra la forma de hacerlo:</p>
<pre class="r"><code>A[2,3]   # Se selecciona el valor de la fila 2, columna 3</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>A[2,]    # Se selecciona la fila 2 completa</code></pre>
<pre><code>## [1] 4 5 6</code></pre>
<pre class="r"><code>A[,3]    # Se selecciona la columna 3 completa</code></pre>
<pre><code>## [1] 3 6 9</code></pre>
<pre class="r"><code>A[1,2:3] # Se seleccionan el segundo y tercer valor de la fila 1</code></pre>
<pre><code>## [1] 2 3</code></pre>
<p>Tarea:</p>
<ol style="list-style-type: decimal">
<li>Selecciona la submatriz de A formada por la primera y tercera filas</li>
<li>Selecciona la submatriz de A formada por las segunda y tercera columnas de la primera y segunda filas.</li>
</ol>
<p>Si disponemos de varios arreglos de la misma longitud que queremos utilizar como filas (o columnas) de una matriz, podemos utilizar la función <code>rbind()</code> para unirlos por filas, o la función <code>cbind()</code> para unirlos por columnas, como vemos en el siguiente ejemplo:</p>
<pre class="r"><code>vector1 = c(1,2,3,4)
vector2 = c(5,6,7,8)
vector3 = c(9,10,11,12)
M1 = cbind(vector1,vector2,vector3) # Unimos por columnas
M1  </code></pre>
<pre><code>##      vector1 vector2 vector3
## [1,]       1       5       9
## [2,]       2       6      10
## [3,]       3       7      11
## [4,]       4       8      12</code></pre>
<p>Tarea:</p>
<p>Crea una matriz M2 con los arreglos anteriores unidos por filas mediante <code>rbind()</code>. Compara el resultado con la matriz M1 anterior.</p>
<div id="operaciones" class="section level2">
<h2><span class="header-section-number">5.1</span> Operaciones</h2>
<p>La función <code>diag()</code> extrae la diagonal principal de una matriz:</p>
<pre class="r"><code>diag(A)</code></pre>
<pre><code>## [1] 1 5 9</code></pre>
<p>Tarea:</p>
<ul>
<li>Probar el resultado de las funciones diag(A), diag(c(1,2,3,4)), t(A), det(A), diag(1,nrow=4), A+2.</li>
<li>Sumar dos matrices con la misma dimensión.<br />
</li>
<li>Multiplicar dos matrices con la misma dimensión. El operador es <code>%*%</code>.</li>
<li>La inversa de una matriz utilizando solve(A).</li>
<li>Obtener los autovalores y autovectores de A con eigen(A).</li>
</ul>
</div>
</div>
<div id="data.frames" class="section level1">
<h1><span class="header-section-number">6</span> Data.frames</h1>
<p>El término “dataframe” es difícil de traducir al castellano. Podría traducirse como Hoja de datos o Marco de datos. Los dataframes son una clase de objetos especial en R. Normalmente, cuando se realiza un estudio estadístico sobre los sujetos u objetos de una muestra, la información se organiza precisamente en un dataframe: una hoja de datos, en los que cada fila corresponde a un sujeto y cada columna a una variable. La estructura de un data.frame es muy similar a la de una matriz. La diferencia es que una matriz sólo admite valores numéricos, mientras que en un dataframe podemos incluir también datos alfanuméricos.</p>
<div id="creacion" class="section level2">
<h2><span class="header-section-number">6.1</span> Creación</h2>
<p>El siguiente ejemplo nos muestra como crear un data.frame a partir de los datos recogidos sobre una muestra de 10 personas, para cada una de las cuales se ha registrado su edad, sexo y tiempo en minutos que estuvo hablando por teléfono el día antes de la encuesta:</p>
<pre class="r"><code>edad &lt;- c(22, 34, 29, 25, 30, 33, 31, 27, 25, 25)
tiempo &lt;- c(14.21, 10.36, 11.89, 13.81, 12.03, 10.99, 12.48, 13.37, 12.29, 11.92)
sexo &lt;- c(&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;M&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;)
misDatos &lt;- data.frame(edad,tiempo,sexo)
misDatos</code></pre>
<pre><code>##    edad tiempo sexo
## 1    22  14.21    M
## 2    34  10.36    H
## 3    29  11.89    H
## 4    25  13.81    M
## 5    30  12.03    M
## 6    33  10.99    H
## 7    31  12.48    M
## 8    27  13.37    M
## 9    25  12.29    H
## 10   25  11.92    H</code></pre>
<pre class="r"><code>str(misDatos)    # Estructura de &#39;misDatos&#39;</code></pre>
<pre><code>## &#39;data.frame&#39;:    10 obs. of  3 variables:
##  $ edad  : num  22 34 29 25 30 33 31 27 25 25
##  $ tiempo: num  14.2 10.4 11.9 13.8 12 ...
##  $ sexo  : Factor w/ 2 levels &quot;H&quot;,&quot;M&quot;: 2 1 1 2 2 1 2 2 1 1</code></pre>
<pre class="r"><code>names(misDatos)  # Nombre de las variables contenidas en &#39;misDatos&#39;</code></pre>
<pre><code>## [1] &quot;edad&quot;   &quot;tiempo&quot; &quot;sexo&quot;</code></pre>
<p>En este ejemplo hemos creado un data.frame llamado <code>misDatos</code> que contiene a las tres variables <code>edad</code>, <code>tiempo</code> y <code>sexo</code>. La función <code>str()</code> nos muestra la estructura de este objeto, confirmándonos que es un data.frame de tres variables con 10 observaciones cada una. Nos informa además de que las dos primeras variables son numéricas y la tercera, el sexo, es un factor con dos valores, “H” y “M”. La función <code>names()</code> por su parte, nos devuelve los nombres de las variables contenidas en <code>misDatos</code>.</p>
<p>Cuando desde R se leen datos situados en un fichero externo (un fichero de texto, una hoja excel, un archivo de datos de SPSS,…), estos datos se importan en un data.frame.</p>
</div>
<div id="convertir-una-matriz-en-data.frame" class="section level2">
<h2><span class="header-section-number">6.2</span> Convertir una matriz en data.frame</h2>
<pre class="r"><code>str(M1)</code></pre>
<pre><code>##  num [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : NULL
##   ..$ : chr [1:3] &quot;vector1&quot; &quot;vector2&quot; &quot;vector3&quot;</code></pre>
<pre class="r"><code>M2&lt;-as.data.frame(M1)
str(M2)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  3 variables:
##  $ vector1: num  1 2 3 4
##  $ vector2: num  5 6 7 8
##  $ vector3: num  9 10 11 12</code></pre>
</div>
<div id="acceso-a-variables" class="section level2">
<h2><span class="header-section-number">6.3</span> Acceso a variables</h2>
<p>El acceso a los datos que se encuentran en un data.frame es muy similar al acceso a los datos de una matriz que ya vimos en la sección anterior. Sin embargo, para los data.frames R dispone de algunas funciones que facilitan la tarea de seleccionar o filtrar datos. Así por ejemplo, si queremos ver sólo los datos de los sujetos (filas) 3 a 6, escribiríamos:</p>
<pre class="r"><code>misDatos[3:6,] #Mostrar solo las personas de las filas 3 a 6.</code></pre>
<pre><code>##   edad tiempo sexo
## 3   29  11.89    H
## 4   25  13.81    M
## 5   30  12.03    M
## 6   33  10.99    H</code></pre>
<pre class="r"><code>misDatos[,1] #Mostrar solo la edad de las personas.</code></pre>
<pre><code>##  [1] 22 34 29 25 30 33 31 27 25 25</code></pre>
<pre class="r"><code>misDatos$edad #Otra manera de mostrar solo la edad de las personas. </code></pre>
<pre><code>##  [1] 22 34 29 25 30 33 31 27 25 25</code></pre>
<pre class="r"><code>misDatos[,&quot;edad&quot;] #Otra manera de mostrar solo la edad de las personas.</code></pre>
<pre><code>##  [1] 22 34 29 25 30 33 31 27 25 25</code></pre>
<p>Tarea:</p>
<ul>
<li>Probar los siguientes comandos:</li>
</ul>
<pre class="r"><code>medidas &lt;- data.frame(longitud=c(6,4,7), peso=c(240,326,315), diametro=c(8,9,9))
with(medidas,{
  volumen &lt;- longitud*pi*(diametro/2)^2  # Calcula el volumen de los objetos
  densidad &lt;- peso/volumen               # Calcula su densidad
  densidad                            # Muestra los valores de densidad
})</code></pre>
<pre><code>## [1] 0.7957747 1.2810990 0.7073553</code></pre>
<pre class="r"><code>hombres &lt;- subset(misDatos,sexo==&quot;H&quot;)
hombres</code></pre>
<pre><code>##    edad tiempo sexo
## 2    34  10.36    H
## 3    29  11.89    H
## 6    33  10.99    H
## 9    25  12.29    H
## 10   25  11.92    H</code></pre>
<pre class="r"><code>mujeres &lt;- subset(misDatos,sexo==&quot;M&quot;)
mujeres</code></pre>
<pre><code>##   edad tiempo sexo
## 1   22  14.21    M
## 4   25  13.81    M
## 5   30  12.03    M
## 7   31  12.48    M
## 8   27  13.37    M</code></pre>
<pre class="r"><code>mayores &lt;- subset(misDatos,sexo==&quot;H&quot; &amp; edad&gt;30)
mayores</code></pre>
<pre><code>##   edad tiempo sexo
## 2   34  10.36    H
## 6   33  10.99    H</code></pre>
<pre class="r"><code>jov_habladores &lt;- subset(misDatos,sexo==&quot;H&quot; &amp; edad&lt;30 &amp; tiempo&gt;12)
jov_habladores</code></pre>
<pre><code>##   edad tiempo sexo
## 9   25  12.29    H</code></pre>
<pre class="r"><code>extremos &lt;- subset(misDatos,edad&lt;25|edad&gt;30)
extremos</code></pre>
<pre><code>##   edad tiempo sexo
## 1   22  14.21    M
## 2   34  10.36    H
## 6   33  10.99    H
## 7   31  12.48    M</code></pre>
<pre class="r"><code>hombres &lt;- subset(misDatos,sexo==&quot;H&quot;, select=c(edad, tiempo))
hombres</code></pre>
<pre><code>##    edad tiempo
## 2    34  10.36
## 3    29  11.89
## 6    33  10.99
## 9    25  12.29
## 10   25  11.92</code></pre>
<ul>
<li>Construir el subconjunto de las mujeres con edad mayor a 25 y menor a 50 años. Para este subconjunto calcular el tiempo medio de uso del celular.</li>
</ul>
</div>
<div id="eliminar-repetidos.-merge" class="section level2">
<h2><span class="header-section-number">6.4</span> Eliminar repetidos. <code>merge()</code></h2>
<p>Como ya comentamos en la sección de matrices, <code>rbind</code> (acrónimo de rowbind, pegar por filas) permite combinar arreglos (o matrices o data.frames) “uno debajo del otro”:</p>
<pre class="r"><code>animales1 &lt;- data.frame(animal=c(&quot;vaca&quot;,&quot;perro&quot;,&quot;rana&quot;,&quot;lagarto&quot;,&quot;mosca&quot;,&quot;jilguero&quot;), 
                       clase=c(&quot;mamífero&quot;,&quot;mamífero&quot;,&quot;anfibio&quot;,&quot;reptil&quot;,&quot;insecto&quot;,&quot;ave&quot;))
animales2 &lt;- data.frame(animal=c(&quot;atún&quot;, &quot;cocodrilo&quot;, &quot;gato&quot;,&quot;rana&quot;), clase=c(&quot;pez&quot;, &quot;reptil&quot;, &quot;mamífero&quot;,&quot;anfibio&quot;))

animales3 &lt;- rbind(animales1,animales2)</code></pre>
<p>El comando <code>rbind</code> no controla la posible aparición de casos repetidos en los dos dataframes (podemos comprobar que la <strong>rana</strong> está repetida en el dataframe ‘animales3’). La función <code>merge()</code> evita este problema; utilizando la opción <code>all=TRUE</code> ó <code>all=FALSE</code> (valor por defecto) se consigue que se muestren todos los datos de ambos data.frames, o sólo aquellos que son comunes a ambos:</p>
<pre class="r"><code>animales4=merge(animales1,animales2)
animales5=merge(animales1,animales2,all=TRUE)</code></pre>
<p>Si los data.frames tienen estructura distinta, pero contienen variables en común que permiten identificar unívocamente a los mismos objetos en ambos conjuntos, también podemos combinarlos mediante <code>merge()</code>:</p>
<pre class="r"><code>superficieAnimales=data.frame(animal=c(&quot;perro&quot;,&quot;tortuga&quot;,&quot;jilguero&quot;, 
                                       &quot;cocodrilo&quot;,&quot;vaca&quot;,&quot;lagarto&quot;,&quot;sardina&quot;),
                     superficie=c(&quot;pelo&quot;,&quot;placas óseas&quot;,&quot;plumas&quot;,
                                  &quot;escamas&quot;,&quot;pelo&quot;,&quot;escamas&quot;,&quot;escamas&quot;))

merge(animales3,superficieAnimales) # Muestra sólo los animales comunes a ambos dataframes</code></pre>
<pre><code>##      animal    clase superficie
## 1 cocodrilo   reptil    escamas
## 2  jilguero      ave     plumas
## 3   lagarto   reptil    escamas
## 4     perro mamífero       pelo
## 5      vaca mamífero       pelo</code></pre>
<pre class="r"><code>merge(animales3,superficieAnimales, all.x=TRUE) # Muestra todos los animales del primer dataframe.</code></pre>
<pre><code>##       animal    clase superficie
## 1   jilguero      ave     plumas
## 2    lagarto   reptil    escamas
## 3      mosca  insecto       &lt;NA&gt;
## 4      perro mamífero       pelo
## 5       rana  anfibio       &lt;NA&gt;
## 6       rana  anfibio       &lt;NA&gt;
## 7       vaca mamífero       pelo
## 8       atún      pez       &lt;NA&gt;
## 9  cocodrilo   reptil    escamas
## 10      gato mamífero       &lt;NA&gt;</code></pre>
<pre class="r"><code>merge(animales3,superficieAnimales, all.y=TRUE) # Muestra todos los animales del segundo dataframe.</code></pre>
<pre><code>##      animal    clase   superficie
## 1  jilguero      ave       plumas
## 2   lagarto   reptil      escamas
## 3     perro mamífero         pelo
## 4      vaca mamífero         pelo
## 5 cocodrilo   reptil      escamas
## 6   sardina     &lt;NA&gt;      escamas
## 7   tortuga     &lt;NA&gt; placas óseas</code></pre>
</div>
<div id="ordenamiento" class="section level2">
<h2><span class="header-section-number">6.5</span> Ordenamiento</h2>
<p>Para ordenar un dataframe hemos de aplicar la función <code>order()</code> al elemento o elementos por el que queramos ordenar, y utilizar el resultado de esta función como índice del data.frame.</p>
<p>Por ejemplo, si queremos ordenar el dataframe <code>animales1</code> por orden alfabético de animales, haríamos:</p>
<pre class="r"><code>ordenacion &lt;- order(animales1$animal) # Posiciones dentro del dataframe &#39;animales1&#39; de los animales ordenados alfabéticamente

animales1 &lt;- animales1[ordenacion,]  # Se reordenan las filas del dataframe animales1

animales1 &lt;- animales1[order(animales1$animal),]  # lo mismo pero en una sola línea de código.</code></pre>
<p>Si queremos ordenar nuestro primer data.frame (<code>misDatos</code>) primero por edad y luego por tiempo utilizando el celular:</p>
<pre class="r"><code>misDatos &lt;- misDatos[order(misDatos$edad,misDatos$tiempo),]</code></pre>
</div>
<div id="funcion-table-1" class="section level2">
<h2><span class="header-section-number">6.6</span> función <code>table()</code></h2>
<p>Ya utilizamos la función <code>table()</code> en arreglos. Lo hicimos para saber cuántas repeticiones tenía cada elemento de un arreglo. Esta función también se puede usar en matrices o data.frames:</p>
<pre class="r"><code>table(misDatos[,&quot;sexo&quot;])</code></pre>
<pre><code>## 
## H M 
## 5 5</code></pre>
<pre class="r"><code>table(misDatos[,c(&quot;sexo&quot;, &quot;edad&quot;)])</code></pre>
<pre><code>##     edad
## sexo 22 25 27 29 30 31 33 34
##    H  0  2  0  1  0  0  1  1
##    M  1  1  1  0  1  1  0  0</code></pre>
</div>
</div>
<div id="listas" class="section level1">
<h1><span class="header-section-number">7</span> Listas</h1>
<p>Una lista, en R, se puede ver como un contenedor de objetos que pueden ser de cualquier clase: números, arreglos, matrices, funciones, data.frames, incluso otras listas. Una lista puede contener a la vez otros objetos, que pueden ser además de distintas dimensiones.</p>
<p>Por ejemplo, podemos crear una lista que contenga el data.frame <code>misDatos</code>, la matriz <code>A</code>, la matriz <code>M</code>, el arreglo <code>x &lt;- c(1,2,3,4)</code> y la constante <code>e &lt;- exp(1)</code>:</p>
<pre class="r"><code>A &lt;- matrix(1:9,nrow=3)
M &lt;- matrix(1,4,nrow=2)
MiLista &lt;- list(misDatos,A,M=M,x=c(1,2,3,4),e=exp(1))</code></pre>
<p>Obsérvese a continuación cómo podemos acceder a los distintos elementos de la lista. Póngase especial atención a lo que ocurre con los elementos <code>misDatos</code> y <code>A</code>, cuyo nombre no se utilizó explícitamente en la declaración de la lista:</p>
<pre class="r"><code>MiLista$misDatos</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>MiLista[[1]]</code></pre>
<pre><code>##    edad tiempo sexo
## 1    22  14.21    M
## 10   25  11.92    H
## 9    25  12.29    H
## 4    25  13.81    M
## 8    27  13.37    M
## 3    29  11.89    H
## 5    30  12.03    M
## 7    31  12.48    M
## 6    33  10.99    H
## 2    34  10.36    H</code></pre>
<pre class="r"><code>MiLista$A</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>MiLista[[2]]</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9</code></pre>
<pre class="r"><code>MiLista$M</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    1    1    1</code></pre>
<pre class="r"><code>MiLista$x</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<p>Como vemos, para acceder a los objetos que forman parte de una lista, basta con añadir su nombre a continuación del de la lista, separados por el símbolo <code>$</code>, o bien con el índice de posición dentro de la lista con doble corchete [[]]. Nótese que los objetos <code>misDatos</code> y <code>A</code> no tienen nombre dentro de la lista, por lo que hemos de referirnos a ellos como <code>MiLista[[1]]</code> o <code>MiLista[[2]]</code>. Sin embargo, el objeto <code>M</code> sí que tiene nombre. Para que un objeto dentro de una lista tenga nombre, éste debe declararse explícitamente en la construcción de la lista, tal como se hizo con <code>M</code>, <code>x</code> o `e.</p>
<p>R utiliza las listas, sobre, todo como salida de los distintos procedimientos estadísticos. Así, por ejemplo, al realizar un contraste de medias de dos poblaciones, R calcula, entre otras cosas, la diferencia de medias muestrales, el valor del estadístico de contraste, el p-valor del test y el intervalo de confianza para la diferencia observada. Todos estos términos forman parte de una lista. La sintaxis para comparar, por ejemplo, el tiempo medio de uso del celular entre hombres y mujeres a partir de nuestros datos sería:</p>
<pre class="r"><code>t.test(tiempo~sexo, data=misDatos)</code></pre>
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  tiempo by sexo
## t = -3.1333, df = 7.8535, p-value = 0.01427
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -2.9378177 -0.4421823
## sample estimates:
## mean in group H mean in group M 
##           11.49           13.18</code></pre>
<p>Si guardamos el resultado de este contraste en el objeto contraste, podemos observar que tiene estructura de lista:</p>
<pre class="r"><code>contraste &lt;- t.test(tiempo~sexo, data=misDatos)
str(contraste)</code></pre>
<pre><code>## List of 9
##  $ statistic  : Named num -3.13
##   ..- attr(*, &quot;names&quot;)= chr &quot;t&quot;
##  $ parameter  : Named num 7.85
##   ..- attr(*, &quot;names&quot;)= chr &quot;df&quot;
##  $ p.value    : num 0.0143
##  $ conf.int   : num [1:2] -2.938 -0.442
##   ..- attr(*, &quot;conf.level&quot;)= num 0.95
##  $ estimate   : Named num [1:2] 11.5 13.2
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;mean in group H&quot; &quot;mean in group M&quot;
##  $ null.value : Named num 0
##   ..- attr(*, &quot;names&quot;)= chr &quot;difference in means&quot;
##  $ alternative: chr &quot;two.sided&quot;
##  $ method     : chr &quot;Welch Two Sample t-test&quot;
##  $ data.name  : chr &quot;tiempo by sexo&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;htest&quot;</code></pre>
<p>Si deseamos extraer, por ejemplo, solo el intervalo de confianza de la lista anterior nos bastaría con ejecutar:</p>
<pre class="r"><code>contraste$conf.int</code></pre>
<pre><code>## [1] -2.9378177 -0.4421823
## attr(,&quot;conf.level&quot;)
## [1] 0.95</code></pre>
<hr />
</div>
<div id="coercion" class="section level1">
<h1><span class="header-section-number">8</span> Coerción</h1>
<p>En R es posible “forzar” (“coerce”) la conversión de una clase de datos en otra, mediante comandos de la forma as.class. Por ejemplo:</p>
<pre class="r"><code>x=&quot;1&quot;
x</code></pre>
<pre><code>## [1] &quot;1&quot;</code></pre>
<pre class="r"><code>class(x)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>y=as.integer(x)
y</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>class(x)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>z=as.character(y)
z</code></pre>
<pre><code>## [1] &quot;1&quot;</code></pre>
<pre class="r"><code>class(z)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<hr />
</div>
<div id="algunas-operaciones-basicas" class="section level1">
<h1><span class="header-section-number">9</span> Algunas operaciones básicas</h1>
<p>R tiene un manejo muy potente de operaciones entre tipos primitivos &lt;-&gt; arreglos &lt;-&gt; matrices. Veamos unos ejemplos:</p>
<pre class="r"><code>a &lt;- c(1,2,3,4)
# operaciones entre escalares y arreglos:
a + 5</code></pre>
<pre><code>## [1] 6 7 8 9</code></pre>
<pre class="r"><code>a*4</code></pre>
<pre><code>## [1]  4  8 12 16</code></pre>
<pre class="r"><code>b &lt;- a - 10
sqrt(a)</code></pre>
<pre><code>## [1] 1.000000 1.414214 1.732051 2.000000</code></pre>
<pre class="r"><code>log(a)</code></pre>
<pre><code>## [1] 0.0000000 0.6931472 1.0986123 1.3862944</code></pre>
<pre class="r"><code># operaciones sobre arreglos: 
c &lt;- sort(a)
d &lt;- sort(a,decreasing = TRUE)
min(a)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>e &lt;- c(TRUE,FALSE,FALSE,TRUE)
a[e]</code></pre>
<pre><code>## [1] 1 4</code></pre>
<pre class="r"><code>a &lt;- c(10,20,30,40,NA)
sum(a)</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>sum(a, na.rm = TRUE) # el parámetro na.rm = TRUE significa que no se deben tener en cuenta los valores NA. </code></pre>
<pre><code>## [1] 100</code></pre>
<pre class="r"><code>is.na(a)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>a[!is.na(a)]</code></pre>
<pre><code>## [1] 10 20 30 40</code></pre>
<pre class="r"><code>b &lt;- a[!is.na(a)]
b &lt;- a[a&lt;6]</code></pre>
<div id="funciones-matematicas" class="section level2">
<h2><span class="header-section-number">9.1</span> Funciones matemáticas</h2>
<p>R cuenta con un catálogo muy completo de funciones matemáticas. Por citar unas pocas: logaritmo neperiano (log), exponencial (exp), seno (sin), coseno (cos), valor absoluto (abs), parte entera (floor), redondeo (round). Cuando una función se aplica a un arreglo, se aplica a todos y cada uno de sus elementos:</p>
<pre class="r"><code>x &lt;- 1

x^2</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>log(x)</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>3*x</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>1/exp(x)</code></pre>
<pre><code>## [1] 0.3678794</code></pre>
</div>
<div id="algunas-funciones" class="section level2">
<h2><span class="header-section-number">9.2</span> Algunas funciones</h2>
<p>Instrucciones simples y útiles:</p>
<pre class="r"><code># cargar números reales hasta que se presione Enter, y guardarlos en la variable a:
a&lt;-scan(what=double(0))</code></pre>
<p>Otros comandos:</p>
<p>Sugerimos que explores, por tu cuenta, los siguientes comandos: <code>help(repeat)</code>, <code>help(break)</code>, <code>help(next)</code>, <code>help(switch)</code>.</p>
</div>
</div>
<div id="algunos-conceptos-algoritmicos-en-r" class="section level1">
<h1><span class="header-section-number">10</span> Algunos conceptos algorítmicos en R</h1>
<div id="flujos-de-control" class="section level2">
<h2><span class="header-section-number">10.1</span> Flujos de control</h2>
<div id="if" class="section level3">
<h3><span class="header-section-number">10.1.1</span> if</h3>
<pre class="r"><code>x &lt;- 0.1
if( x &lt; 0.2)
  {
     x &lt;- x + 1
     cat(&quot;Incremento el número!\n&quot;)
  }
if( x == 0)
  {
     cat(&quot;El número vale 0!\n&quot;)
} else {
     cat(&quot;El número es distinto a 0\n&quot;)
  }
x</code></pre>
</div>
<div id="for" class="section level3">
<h3><span class="header-section-number">10.1.2</span> for</h3>
<pre class="r"><code># op1:
for(cont in (1:10)){
  print(paste0(&quot;Iteración número: &quot;,cont))
}

# op2:
for (cont in seq(0,1,by=0.3)){
  print(paste0(&quot;Iteración número: &quot;,cont))
 }

# op3:
x &lt;- c(1,2,4,8,16)
for (loop in x)
 {
    cat(&quot;Valor de la iteración: &quot;,loop,&quot;\n&quot;);
 }</code></pre>
</div>
<div id="while" class="section level3">
<h3><span class="header-section-number">10.1.3</span> while</h3>
<p>Probar el siguiente programa y explicar qué operación realiza:</p>
<pre class="r"><code>lupe &lt;- 1
x &lt;- 1
while(x &lt; 4)
 {
    x &lt;- rnorm(1,mean=2,sd=3)
    cat(&quot;trying this value: &quot;,x,&quot; (&quot;,lupe,&quot; times in loop)\n&quot;);
    lupe &lt;- lupe + 1
 }</code></pre>
</div>
<div id="la-familia-de-funciones-apply" class="section level3">
<h3><span class="header-section-number">10.1.4</span> La familia de funciones <code>apply</code></h3>
<p>Las funciones <code>apply()</code>, <code>sapply()</code>, <code>lapply()</code> y <code>tapply()</code> resultan extremadamente útiles también para evitar bucles. Su objetivo fundamental es aplicar (de ahí el nombre) una función a todos los elementos de un objeto. En realidad son funciones que de alguna manera ejecutan un bucle, pero este bucle se ejecuta en código compilado lo que hace que sea más rápido que utilizar los comandos <code>for</code>, <code>repeat</code> o <code>while</code> que siempre deben ser interpretados. No siempre será posible sustituir un bucle por una función de la familia <code>apply</code>, pero cuando lo sea, su utilización es muy ventajosa.</p>
<p>Concretamente:</p>
<ul>
<li><code>apply(M,i,fun)</code>: si <code>i</code> vale 1, aplica la función <code>fun</code> a todas las filas de la matriz <code>M</code>; si `i vale 2, la aplica a las columnas.</li>
</ul>
<p>Por ejemplo, supongamos que queremos calcular la suma de los cuadrados de cada fila y de cada columna de una matriz de términos aleatorios:</p>
<pre class="r"><code>A = matrix(runif(50),nrow=10) # Matriz de dimensión 10x10 cuyos elementos son valores
                               # aleatorios con distribución uniforme en (0,1)
A</code></pre>
<pre><code>##            [,1]      [,2]       [,3]       [,4]      [,5]
##  [1,] 0.4244510 0.8151665 0.85698484 0.10866567 0.1253992
##  [2,] 0.8325065 0.8244143 0.12438446 0.06074222 0.4011553
##  [3,] 0.4934755 0.6172492 0.68164036 0.75377969 0.3142090
##  [4,] 0.4208511 0.2341311 0.64809209 0.79733000 0.8206333
##  [5,] 0.5541963 0.9180135 0.84430555 0.91126376 0.5448159
##  [6,] 0.4315106 0.3393182 0.48503421 0.56929057 0.9622677
##  [7,] 0.6849021 0.8212080 0.98139259 0.04282647 0.4233688
##  [8,] 0.4633069 0.1192685 0.58459964 0.02342615 0.2443315
##  [9,] 0.1549693 0.5770501 0.08455527 0.52130642 0.3516558
## [10,] 0.1648496 0.5046229 0.85126622 0.21610570 0.7673463</code></pre>
<pre class="r"><code>sumCuadrados=function(x){sum(x^2)}  # Función que calcula la suma de cuadrados de 
                                    # los términos de un vector x
apply(A,1,sumCuadrados)  # Devuelve la suma de cuadrados de cada fila de A</code></pre>
<pre><code>##  [1] 1.6066113 1.5528127 1.7560594 1.9611305 2.9899601 1.7866474 2.2876800 0.6308817 0.7595740
## [10] 1.6419959</code></pre>
<pre class="r"><code>apply(A,2,sumCuadrados)  # Devuelve la suma de cuadrados de cada columna de A</code></pre>
<pre><code>## [1] 2.522129 4.014094 4.619353 2.694755 3.123021</code></pre>
<ul>
<li><p><code>lapply(L,fun)</code>: aplica la función <code>fun</code> a todos los elementos de la lista <code>L</code>. El resultado se devuelve también en una lista.</p></li>
<li><p><code>sapply(L,fun)</code>: al igual que <code>lapply()</code>, aplica la función <code>fun</code> a todos los elementos de la lista <code>L</code>, pero devuelve el resultado en forma de vector o matriz</p></li>
<li><p><code>tapply(variable,factor,fun)</code>: aplica la función <code>fun</code> a cada uno de los grupos de datos de variable definidos por los niveles de factor.</p></li>
</ul>
<pre class="r"><code>grupo=data.frame(edad=c(12,13,12,11,13,14,15,11),sexo=c(&quot;H&quot;,&quot;M&quot;,&quot;H&quot;,&quot;H&quot;,&quot;M&quot;,&quot;H&quot;,&quot;M&quot;,&quot;H&quot;))
tapply(grupo$edad,grupo$sexo,mean) # Edad media para cada sexo</code></pre>
<pre><code>##        H        M 
## 12.00000 13.66667</code></pre>
</div>
</div>
<div id="funciones" class="section level2">
<h2><span class="header-section-number">10.2</span> Funciones</h2>
<p>R permite la programación de funciones propias. En una función tenemos 3 tipos de elementos:</p>
<ul>
<li>Argumentos (o valores de entrada).</li>
<li>Cuerpo: operaciones que han de realizarse. Se deben localizar entre corchetes “{}”.</li>
<li>Resultado (o valores de salida): la última expresión que se ejecuta.</li>
</ul>
<pre><code>mifuncion &lt;- function(argumento1, argumento2, ...) {
cuerpo
resultado
}</code></pre>
<p>Las funciones también son objetos y por tanto les daremos un nombre, en este caso se llamará “mifuncion”. Debes evitar utilizar nombres que ya estén en uso en R, por ejemplo “mean”.</p>
<p>La última línea del código será el valor que devolverá la función.</p>
<p>Ejemplo1 de función:</p>
<pre class="r"><code>suma &lt;- function(x,y){
     # suma de los elementos &quot;x&quot; e &quot;y”
     x+y
}</code></pre>
<p>Una vez que ejecutes este comando, busca en el area Enviroment. Debajo de las variables, encontrarás a las funciones en memoria. Deberás encontrar la función <code>suma</code>.</p>
<p>Para probar la nueva función, en la consola puedes escribir:</p>
<pre class="r"><code>suma(2,3)</code></pre>
<p>Ejemplo2 de función:</p>
<pre class="r"><code>hipotenusa&lt;-function(cateto1, cateto2){
 h&lt;-sqrt(cateto1^2+cateto2^2)
 list(cateto1=cateto1,cateto2=cateto2,hipotenusa=h)
}</code></pre>
<div id="buena-practica-para-la-programacion-de-funciones" class="section level3">
<h3><span class="header-section-number">10.2.1</span> Buena práctica para la programación de funciones</h3>
<p>Es recomendable programar las funciones en un archivo .r y, cuando se los necesita, cargarlo en memoria con el comando:</p>
<pre class="r"><code>source(&#39;misFunciones.R&#39;)</code></pre>
<p>Tarea: - definir una función que devuelva el valor absoluto de un entero.</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
